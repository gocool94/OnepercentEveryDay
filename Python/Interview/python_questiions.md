Python Advanced coding

1. Closures and Lexical Scoping
   -
2. Decorators and Function Wrapping
3. Metaclasses and Class Customization
4. Context Managers and the `with` Statement
5. Asynchronous Programming and `async/await`
6. Coroutines and Generators
7. Type Annotations and Type Hinting
8. Garbage Collection and Memory Management
9. Global Interpreter Lock (GIL) and Concurrency
10. Multiple Inheritance and Method Resolution Order (MRO)
11. Duck Typing and EAFP (Easier to Ask for Forgiveness than Permission)
12. List Comprehensions, Generator Expressions, and Dict Comprehensions
13. Python Data Model and Dunder Methods
14. Python Packaging and Virtual Environments
15. Magic Methods and Operator Overloading
16. Namedtuples and Data Structuring
17. Regular Expressions and the `re` Module
18. Functional Programming in Python
19. Immutable vs. Mutable Data Types
20. `collections` Module and Advanced Data Structures
21. Memory Views and NumPy
22. File Handling and Contextlib
23. Python's Command-Line Argument Parsing
24. Debugging and Profiling Techniques
25. Performance Optimization and Cython
26. Packaging and Distributing Python Libraries
27. Metaprogramming and `eval()`/`exec()` Functions
28. Working with Binary Data and `struct` Module
29. Regular Expressions and Lookahead/Lookbehind
30. Python's Memory Management and Reference Counting
31. Python's Data Serialization (JSON, Pickle, YAML)
32. Custom Iterators and Iteration Protocols
33. Unicode and Character Encoding in Python
34. Networking and Sockets in Python
35. Threading vs. Multiprocessing
36. Python's Built-in Testing Framework (`unittest`)
37. Python's Logging and Log Handling
38. Advanced Exception Handling and Custom Exceptions
39. Dynamic Code Execution and Security Considerations
40. Decorators for Memoization and Caching
41. Using `functools` for Higher-Order Functions
42. Working with Dates and Times (`datetime` and `dateutil`)
43. Using `argparse` for Command-Line Interfaces
44. Python's `asyncio` and Event Loops
45. Custom Context Managers and the `contextlib` Module
46. Database Interaction with Python (`sqlite3`, ORM frameworks)
47. Design Patterns in Python (Singleton, Factory, Observer, etc.)
48. Managing Dependencies with `pip` and `requirements.txt`
49. Functional Programming Concepts (Map, Filter, Reduce)
50. Decorators for Authorization and Authentication
51. Profiling and Optimizing Python Code
52. Working with Binary Files and `io` Module
53. Implementing Custom Context Managers
54. Secure Coding Practices and Input Validation
55. Designing RESTful APIs with Flask or Django
56. Data Serialization with Protobuf and MessagePack
57. Decorators for Rate Limiting and Throttling
58. Packaging Python Applications with `setuptools`
59. Using Python for Web Scraping (Beautiful Soup, Requests)
60. Customizing Python's Import Mechanism
61. Creating and Consuming REST APIs with `requests`
62. Working with Encodings and Character Sets
63. C Extensions and the `ctypes` Module
64. Implementing Design Patterns in Python
65. Advanced Usage of Python's `collections` Module
66. Metaclasses and Code Generation
67. Web Development with Django (ORM, Views, Forms)
68. Using Python in Data Science (Pandas, Matplotlib)
69. GUI Development with Tkinter or PyQt
70. Database Interaction with SQLAlchemy
71. Regular Expressions and Advanced Patterns
72. Debugging Techniques and Tools (pdb, py-spy)
73. Advanced Usage of `asyncio` for Networking
74. Concurrency Patterns and Parallelism in Python
75. Unit Testing with Mocking and Test Fixtures
76. Customizing Python's Logging Framework
77. Python's `concurrent.futures` for Parallelism
78. Continuous Integration and Deployment (CI/CD)
79. Creating and Consuming REST APIs with Flask
80. Machine Learning with Python (scikit-learn)
81. Web Scraping with Scrapy
82. Working with GPU in Python (CUDA, PyTorch, TensorFlow)
83. WebSockets and Real-Time Communication
84. Python's `multiprocessing` for Parallelism
85. Implementing Microservices in Python
86. Functional Programming Libraries (toolz, funcy)
87. Securely Storing and Managing Secrets
88. GraphQL with Python (Graphene, Ariadne)
89. Python's `asyncio` Patterns (Task Chaining, etc.)
90. Interactive Debugging with IPython
91. Performance Profiling with `cProfile` and `line_profiler`
92. Introduction to Cython for Performance Optimization
93. Secure Authentication and Authorization Practices
94. Web Development with FastAPI
95. Python's `asyncio` Advanced Patterns (Streams, Protocols)
96. Data Analysis with Python (NumPy, Pandas, Jupyter)
97. GUI Development with Kivy
98. Automated Testing and Test Driven Development (TDD)
99. Memory Management Optimization Techniques
100. Exploring Python's Standard Library Modules

OOPS

1. **Explain the key principles of object-oriented programming (OOP).**
2. **What is a class in Python, and how do you define a class?**
3. **Explain the difference between a class and an object in Python.**
4. **What are instance variables and class variables? How do they differ?**
5. **Discuss the concept of encapsulation in object-oriented programming.**
6. **Explain the significance of constructors (`__init__` method) in Python classes.**
7. **What is inheritance in Python, and how is it implemented? Provide an example.**
8. **Explain the difference between single inheritance and multiple inheritance in Python.**
9. **Discuss the concept of method overriding in Python. Provide an example.**
10. **What is polymorphism in Python? How is it achieved through method overriding?**
11. **Explain the difference between class methods and instance methods in Python.**
12. **Discuss the concept of abstract classes in Python and how they are implemented using the `abc` module.**
13. **What is an interface in Python? How can you achieve interface-like behavior?**
14. **Explain the usage of magic methods (`__str__`, `__repr__`, etc.) in Python classes.**
15. **Discuss the concept of operator overloading in Python classes.**
16. **What is a property in Python, and how is it implemented using the `property` decorator?**
17. **Explain the concept of method resolution order (MRO) in Python classes.**
18. **Discuss the use of the `super()` function in Python classes for method invocation.**
19. **What is a metaclass in Python? How can you use metaclasses to customize class creation?**
20. **Explain the role of the `@classmethod` decorator in Python and provide examples.**
21. **Discuss the concept of composition and aggregation in object-oriented programming.**
22. **What is method chaining in Python, and how is it achieved?**
23. **Explain the concept of data hiding and information hiding in Python classes.**
24. **Discuss the use of instance variables and class variables in Python classes.**
25. **What is an abstract method in Python? How is it defined using the `abc` module?**
26. **Explain the use of the `staticmethod` decorator in Python classes.**
27. **Discuss the differences between shallow copy and deep copy in Python classes.**
28. **What is dynamic binding in Python, and how does it relate to polymorphism?**
29. **Explain the concept of duck typing and how it is implemented in Python.**
30. **Discuss the difference between composition and inheritance in Python.**
31. **What is the purpose of the `__del__` method in Python classes?**
32. **Explain the concept of namespaces in Python classes. How are namespaces managed?**
33. **Discuss the use of the `__slots__` attribute in Python classes for memory optimization.**
34. **What are mixins in Python, and how can you use them to extend class functionality?**
35. **Explain the role of class decorators in Python, and provide examples of their use.**
36. **Discuss the concept of static methods in Python and their advantages.**
37. **What is the diamond problem in object-oriented programming? How does Python handle it?**
38. **Explain the concept of private, protected, and public access modifiers in Python.**
39. **Discuss the use of properties to implement getter and setter methods in Python.**
40. **What is the purpose of the `super()` function in Python, and how does it work?**
41. **Explain the concept of composition over inheritance in Python.**
42. **Discuss the benefits and drawbacks of multiple inheritance in Python.**
43. **What is the purpose of the `staticmethod` decorator in Python classes?**
44. **Explain the concept of abstract base classes (ABCs) in Python and their significance.**
45. **Discuss the use of metaclasses to customize class creation and behavior in Python.**
46. **What is method chaining in Python, and how can it improve code readability?**
47. **Explain the role of the `__enter__` and `__exit__` methods in Python context managers.**
48. **Discuss the differences between encapsulation and abstraction in Python.**
49. **What is the purpose of the `__new__` method in Python classes?**
50. **Explain the concept of interface-based programming in Python and its benefits.**
51. **Discuss the use of mixins to add behavior to classes in Python.**
52. **What is the purpose of the `__init__` method in Python classes, and how is it different from the constructor in other languages?**
53. **Explain the concept of cooperative multiple inheritance in Python.**
54. **Discuss the concept of type hinting in Python and how it improves code quality.**
55. **What is a factory method in Python? How is it used to create objects?**
56. **Explain the concept of adapter design pattern in Python and provide an example.**
57. # \*\*Discuss the concept
    of the composite design pattern in Python and its applications.\*\*
58. **What is the strategy design pattern in Python, and how is it implemented?**
59. **Explain the concept of the observer design pattern in Python and provide an example.**
60. **Discuss the singleton design pattern in Python and its implementation techniques.**
61. **What is the builder design pattern in Python, and how is it used to construct complex objects?**
62. **Explain the facade design pattern in Python and its role in simplifying complex systems.**
63. **Discuss the adapter design pattern in Python and how it helps integrate incompatible interfaces.**
64. **What is the command design pattern in Python, and how is it used to encapsulate requests?**
65. **Explain the iterator design pattern in Python and how it facilitates traversing collections.**
66. **Discuss the template method design pattern in Python and its use in defining algorithm structures.**
67. **What is the chain of responsibility design pattern in Python, and how is it used for handling requests?**
68. **Explain the state design pattern in Python and its role in modeling object behavior based on state changes.**
69. **Discuss the proxy design pattern in Python and its use in controlling access to objects.**
70. **What is the flyweight design pattern in Python, and how does it optimize memory usage?**
71. **Explain the memento design pattern in Python and how it captures and restores object states.**
72. **Discuss the mediator design pattern in Python and its role in facilitating communication between objects.**
73. **What is the visitor design pattern in Python, and how does it allow adding new operations to objects without modifying their structure?**
74. **Explain the interpreter design pattern in Python and its use in defining a language grammar and interpreter.**
75. **Discuss the decorator design pattern in Python and its role in dynamically adding behavior to objects.**
76. **What is the prototype design pattern in Python, and how is it used to create new instances by copying existing ones?**
77. **Explain the command design pattern in Python and its role in encapsulating requests as objects.**
78. **Discuss the observer design pattern in Python and how it facilitates dependency management between objects.**
79. **What is the chain of responsibility design pattern in Python, and how is it used for handling requests through a chain of handlers?**
80. **Explain the strategy design pattern in Python and its use in defining interchangeable behaviors for objects.**
81. **Discuss the adapter design pattern in Python and how it allows objects with incompatible interfaces to work together.**
82. **What is the template method design pattern in Python, and how is it used to define the structure of an algorithm while allowing subclasses to provide specific implementations?**
83. **Explain the bridge design pattern in Python and its use in separating abstraction and implementation in hierarchies.**
84. **Discuss the composite design pattern in Python and how it allows composing objects into tree structures to represent part-whole hierarchies.**
85. **What is the proxy design pattern in Python, and how does it provide a surrogate or placeholder for another object to control access to it?**
86. **Explain the visitor design pattern in Python and how it separates the algorithm from the object structure on which it operates.**
87. **Discuss the facade design pattern in Python and its role in providing a unified interface to a set of interfaces in a subsystem.**
88. **What is the memento design pattern in Python, and how is it used to capture and restore an object's internal state?**
89. **Explain the interpreter design pattern in Python and how it defines a grammar for a language and provides an interpreter to interpret sentences in the language.**
90. **Discuss the mediator design pattern in Python and how it defines an object that encapsulates how a set of objects interact, promoting loose coupling between them.**
91. **What is the flyweight design pattern in Python, and how does it allow sharing objects to support a large number of fine-grained objects efficiently?**
92. **Explain the decorator design pattern in Python and how it allows adding behavior to objects dynamically by placing them inside wrapper objects that contain the behavior.**
93. **Discuss the prototype design pattern in Python and how it allows creating new objects by copying an existing object, including its state.**
94. **What is the builder design pattern in Python, and how does it separate the construction of a complex object from its representation, allowing the same construction process to create various representations?**
95. **Explain the chain of responsibility design pattern in Python and how it allows passing requests along a chain of handlers until they are handled by an appropriate handler.**
96. **Discuss the state design pattern in Python and how it allows an object to change its behavior when its internal state changes, effectively creating different behaviors for different states.**
97. **What is the command design pattern in Python, and how does it encapsulate a request as an object, allowing parameterization of clients with different requests, queuing, logging, and undoable operations?**
98. **Explain the observer design pattern in Python and how it defines a dependency between objects so that when one object changes its state, all its dependents are notified and updated automatically.**
99. **Discuss the strategy design pattern in Python and how it defines a family of algorithms, encapsulates each algorithm, and makes them interchangeable, allowing the client to choose an algorithm from a family of algorithms.**
100. **What is the template method design pattern in Python, and how does it define the structure of an algorithm in a superclass while allowing subclasses to provide specific implementations for some steps of the algorithm?**

101. **Discuss the facade design pattern in Python and how it simplifies a complex system by providing a unified interface to a set of interfaces in a subsystem.**
102. **What is the bridge design pattern in Python, and how does it decouple abstraction from implementation, allowing both to evolve independently?**
103. **Explain the mediator design pattern in Python and how it defines an object that centralizes communication between a set of objects, promoting loose coupling between them.**
104. **Discuss the chain of responsibility design pattern in Python and how it allows an object to pass a request along a chain of potential handlers until the request is handled or reaches the end of the chain.**
105. **What is the command design pattern in Python, and how does it encapsulate a request as an object, allowing parameterization of clients with different requests, queuing, logging, and undoable operations?**
106. **Explain the observer design pattern in Python and how it establishes a dependency relationship between objects, ensuring that when one object changes its state, its dependents are notified and updated.**
107. **Discuss the strategy design pattern in Python and how it defines a family of interchangeable algorithms, encapsulates each algorithm, and allows clients to choose an algorithm from the family.**
108. **What is the template method design pattern in Python, and how does it define the structure of an algorithm in a superclass while allowing subclasses to provide concrete implementations for certain steps?**
109. **Explain the state design pattern in Python and how it allows an object to change its behavior when its internal state changes, effectively creating different behaviors for different states.**
110. **Discuss the proxy design pattern in Python and how it acts as a surrogate or placeholder for another object to control access to it, adding an extra level of indirection.**
111. **What is the flyweight design pattern in Python, and how does it allow sharing fine-grained objects efficiently to support a large number of objects with minimal memory usage?**
112. **Explain the memento design pattern in Python and how it allows capturing and restoring an object's internal state, providing a way to return an object to a previous state.**
113. **Discuss the interpreter design pattern in Python and how it defines a language grammar and provides an interpreter to evaluate expressions and sentences in the language.**
114. **What is the visitor design pattern in Python, and how does it allow adding new operations to an object structure without modifying the classes of the elements on which the operations work?**
115. **Explain the decorator design pattern in Python and how it allows adding responsibilities to objects dynamically by placing them inside wrapper objects that contain the behavior.**
116. **Discuss the prototype design pattern in Python and how it allows creating new objects by copying an existing object, including its state, to avoid the overhead of creating from scratch.**
117. **What is the builder design pattern in Python, and how does it separate the construction of a complex object from its representation, allowing different representations to be created?**
118. **Explain the abstract factory design pattern in Python and how it provides an interface for creating families of related or dependent objects without specifying their concrete classes.**
119. **Discuss the object pool design pattern in Python and how it creates and maintains a pool of reusable objects, allowing clients to take and return objects as needed.**
120. **What is the proxy design pattern in Python, and how does it provide a surrogate or placeholder for another object to control access to it, acting as an intermediary?**
121. **Explain the command design pattern in Python and how it encapsulates a request as an object, decoupling the sender and receiver of the request and allowing for parameterization.**
122. **Discuss the observer design pattern in Python and how it defines a one-to-many relationship between objects, ensuring that when one object changes state, its dependents are notified.**
123. **What is the strategy design pattern in Python, and how does it define a family of algorithms, encapsulate each algorithm, and make them interchangeable?**
124. **Explain the template method design pattern in Python and how it defines the structure of an algorithm in a superclass but allows subclasses to provide concrete implementations.**
125. **Discuss the state design pattern in Python and how it allows an object to change its behavior when its internal state changes, encapsulating different behaviors as separate classes.**
126. **What is the flyweight design pattern in Python, and how does it minimize memory usage by sharing objects among multiple contexts, avoiding unnecessary object creation?**
127. **Explain the memento design pattern in Python and how it captures an object's internal state, allowing it to be restored to that state without exposing its internal structure.**
128. **Discuss the interpreter design pattern in Python and how it defines a language and provides an interpreter to evaluate sentences and expressions in that language.**
129. **What is the visitor design pattern in Python, and how does it allow adding new operations to an object structure without modifying its classes?**
130. **Explain the decorator design pattern in Python and how it allows adding behavior to objects dynamically by placing them inside wrapper objects that contain the behavior.**
131. **Discuss the prototype design pattern in Python and how it allows creating new objects by copying existing ones, acting as a blueprint for creating similar objects.**
132. **What is the builder design pattern in Python, and how does it separate the construction of a complex object from its representation, allowing the same construction process to create different representations?**
133. **Explain the abstract factory design pattern in Python and how it provides an interface for creating families of related or dependent objects without specifying their concrete classes.**
134. **Discuss the object pool design pattern in Python and how it maintains a pool of reusable objects, allowing clients to take and return objects as needed.**
135. **What is the proxy design pattern in Python, and how does it provide a surrogate or placeholder for another object to control access to it, acting as an intermediary?**
136. **Explain the command design pattern in Python and how it encapsulates a request as an object, decoupling the sender and receiver of the request and allowing for parameterization.**
137. **Discuss the observer design pattern in Python and how it defines a one-to-many relationship between objects, ensuring that when one object changes state, its dependents are notified.**
138. **What is the strategy design pattern in Python, and how does it define a family of algorithms, encapsulate each algorithm, and make them interchangeable?**
139. **Explain the template method design pattern in Python and how it defines the structure of an algorithm in a superclass but allows subclasses to provide concrete implementations.**
140. **Discuss the state design pattern in Python and how it allows an object to change its behavior when its internal state changes, encapsulating different behaviors as separate classes.**

**Interview Problems and Questions:**

31. Write a function to calculate the factorial of a given number using recursion.
32. Implement a function to reverse a string without using built-in functions.
33. Write a program to find the longest palindrome substring in a given string.
34. Implement a function to find the common elements between two sorted arrays.
35. Write a function to calculate the GCD of two numbers using the Euclidean algorithm.
36. Implement a function to check if a given string is an anagram of another string.
37. Write a program to calculate the nth Fibonacci number using recursion.
38. Implement a function to merge two sorted arrays into a single sorted array.
39. Write a function to find the maximum subarray sum in a given array.
40. Implement a function to calculate the power of a number using recursion.

41. Write a program to implement a basic calculator supporting addition, subtraction, multiplication, and division.
42. Implement a function to rotate an array to the right by a given number of steps.
43. Write a function to reverse a linked list.
44. Implement a function to check if a given string is a valid palindrome.
45. Write a program to find the first non-repeating character in a given string.
46. Implement a function to find the intersection of two linked lists.
47. Write a function to remove duplicates from a sorted array.
48. Implement a function to find the majority element in an array.
49. Write a program to implement a stack that supports push, pop, and min operations in O(1) time.
50. Implement a function to convert a binary search tree to a sorted doubly linked list.

51. Write a function to implement a queue using two stacks.
52. Implement a function to find the longest common prefix among an array of strings.
53. Write a program to find the smallest missing positive integer in an array.
54. Implement a function to perform basic string compression using the counts of repeated characters.
55. Write a function to find the peak element in an array (an element greater than its neighbors).
56. Implement a function to find the longest increasing subsequence in an array.
57. Write a program to find the maximum depth of a binary tree.
58. Implement a function to check if a linked list has a cycle.
59. Write a function to remove the nth node from the end of a linked list.
60. Implement a function to merge intervals in a list of sorted intervals.

61. Write a program to calculate the number of ways to climb stairs, considering you can take 1 or 2 steps at a time.
62. Implement a function to calculate the median of two sorted arrays.
63. Write a function to find the longest substring without repeating characters.
64. Implement a function to reverse a linked list in groups of a given size.
65. Write a program to solve the N-Queens problem.
66. Implement a function to implement a basic calculator supporting addition, subtraction, multiplication, division, and parentheses.
67. Write a function to find the longest palindromic substring in a given string.
68. Implement a function to find the first recurring character in a string.
69. Write a program to implement a hash map with put, get, and remove operations.
70. Implement a function to find the kth largest element in an array.

71. Write a function to implement a trie (prefix tree) for efficient string search and insertion.
72. Implement a function to check if a binary tree is a valid binary search tree (BST).
73. Write a program to implement a priority queue using a min-heap.
74. Implement a function to calculate the maximum subarray product in an array.
75. Write a function to find the longest common subsequence of two strings.
76. Implement a function to implement an LRUCache (Least Recently Used Cache) with get and put operations.
77. Write a program to implement a directed graph and perform depth-first and breadth-first traversals.
78. Implement a function to find the shortest path between two nodes in an unweighted graph.
79. Write a function to perform matrix multiplication.
80. Implement a function to find the longest increasing subarray.

81. Write a program to implement a binary search on a sorted array.
82. Implement a function to find the longest subarray with equal number of 0s and 1s.
83. Write a function to check if a given tree is a subtree of another tree.
84. Implement a function to calculate the maximum profit from buying and selling stocks.
85. Write a program to perform matrix exponentiation for calculating Fibonacci numbers.
86. Implement a function to solve the coin change problem using dynamic programming.
87. Write a function to find the longest repeating subsequence in a given string.
88. Implement a function to implement a stack that supports getMin in O(1) time.
89. Write a program to implement a queue using linked lists.
90. Implement a function to reverse words in a given sentence.

91. Write a function to calculate the number of islands in a given 2D grid.
92. Implement a function to find the length of the shortest path in a maze.
93. Write a program to implement the Kadane's algorithm for finding the maximum subarray sum.
94. Implement a function to find the longest substring with at most k distinct characters.
95. Write a function to implement binary search on a rotated sorted array.
96. Implement a function to calculate the longest common prefix among an array of strings.
97. Write a program to implement a hash set with add, remove, and contains operations.
98. Implement a function to find the longest palindromic subsequence in a given string.
99. Write a function to implement the Boyer-Moore string search algorithm.
100.  Implement a function to check if a string is a valid expression containing parentheses, brackets, and braces.
101.  **Class and Objects:**

- Implement a class for a simple bank account with methods for deposit, withdraw, and checking balance.
- Create a class hierarchy for different types of vehicles (car, bike, truck) with shared and specific attributes/methods.

102. **Inheritance and Polymorphism:**

- Create a base class `Shape` with subclasses `Circle` and `Rectangle`. Implement methods to calculate area for each shape.
- Design a class structure for a library system with `Person`, `Author`, and `Book` classes using inheritance.

103. **Encapsulation:**

- Implement a `Student` class with private attributes for name, age, and grade. Provide methods to access and modify these attributes.
- Create a class for a `BankAccount` with a private attribute for balance and methods for deposit and withdrawal.

104. **Abstraction:**

- Implement an abstract class `Animal` with subclasses `Dog` and `Cat`. Define common and specific methods for each subclass.
- Design an abstract class `Shape` with subclasses for different shapes. Implement a method to calculate perimeter in each subclass.

105. **Method Overriding and Overloading:**

- Create a base class `Person` with a method `introduce`. Create subclasses `Student` and `Teacher` that override the `introduce` method.
- Implement a class `Calculator` with methods for addition, subtraction, and multiplication. Use method overloading to support different argument types.

106. **Composition and Aggregation:**

- Create a class `Department` with a list of `Employee` objects as an attribute to represent employee aggregation.
- Implement a class `Car` with a composition relationship to `Engine` and `Wheel` objects.

107. **Interfaces and Abstract Methods:**

- Define an interface `Shape` with an abstract method `calculate_area`. Implement this interface in classes like `Circle` and `Rectangle`.
- Create an abstract class `Transport` with methods for `start`, `stop`, and `accelerate`. Implement this in classes like `Car` and `Bike`.

108. **Static and Class Methods:**

- Implement a class `Math` with static methods for common mathematical operations (addition, subtraction, etc.).
- Create a class `Employee` with a class method to calculate the average salary of all employees.

109. **Operator Overloading:**

- Overload the `+` operator for a class `Vector` to perform vector addition.
- Implement custom comparison methods to compare two objects of a class based on a specific attribute.

110. **Design Patterns:**


    - Implement the Singleton pattern for a class `Logger` to ensure only one instance is created.
    - Use the Factory Method pattern to create different types of `Product` objects based on a given input.

111. **Dependency Injection:**


    - Create a class `EmailSender` that takes an instance of `Logger` as a dependency to log emails sent.
    - Implement a class `PaymentProcessor` that accepts a payment gateway as a parameter to process payments.

112. **Composition Over Inheritance:**


    - Design a class structure for a drawing application using composition to create complex shapes.
    - Create a class `Animal` and a class `Sound` that can be composed to represent the sound an animal makes.

113. **Duck Typing and Polymorphism:**


    - Implement a function that accepts any object with a `speak` method and calls it to produce a sound.
    - Create a generic class `Container` that accepts and manages any type of objects.

114. **Method Chaining:**


    - Implement a class `StringBuilder` with methods to append, reverse, and get the final string. Enable method chaining.
    - Design a class `Query` with methods to add conditions, select columns, and execute the query. Enable method chaining.

115. **Data Hiding and Encapsulation:**


    - Create a class `Person` with private attributes for name and age, and methods to access and update them.
    - Implement a class `BankAccount` with a private attribute for balance and methods to deposit and withdraw money.

OOPS---------------------------------

**Class and Objects:**

1. Implement a class for a basic calculator with methods for addition, subtraction, multiplication, and division.
2. Create a class hierarchy for different types of animals (mammals, birds, fish) with shared and specific attributes/methods.
3. Implement a class for a bank account with methods for deposit, withdrawal, and balance inquiry.
4. Create classes for different shapes (circle, rectangle, triangle) with methods to calculate area and perimeter.
5. Design a class structure for a school management system with classes for students, teachers, and courses.

**Inheritance and Polymorphism:** 6. Implement a base class `Vehicle` and subclasses `Car`, `Bike`, and `Truck` with shared and specific methods/attributes. 7. Create a base class `Shape` and subclasses `Circle` and `Rectangle` with overridden methods for calculating area. 8. Design a class hierarchy for a university system with base class `Person` and subclasses `Student` and `Professor`. 9. Implement a base class `Employee` and subclasses `Manager` and `Developer` with methods to calculate salary. 10. Create classes for different types of employees (full-time, part-time) with methods to calculate pay.

**Encapsulation:** 11. Implement a class for a bank account with private attributes for balance and account number. 12. Create a class for a person with private attributes for name, age, and address. 13. Implement a class for a shopping cart with private attributes for items and methods to add/remove items. 14. Design a class for a social media post with private attributes for content and author.

**Abstraction:** 15. Implement an abstract class `Shape` with subclasses for different shapes and an abstract method for calculating area. 16. Create an abstract class `Animal` with subclasses `Dog`, `Cat`, and `Bird` with abstract and specific methods. 17. Design an abstract class `Vehicle` with subclasses for different types of vehicles and methods for starting and stopping. 18. Implement an abstract class `BankAccount` with methods for deposit and withdrawal in subclasses `Savings` and `Checking`.

**Method Overriding and Overloading:** 19. Create a base class `Animal` with a method `speak` and subclasses `Dog`, `Cat`, and `Bird` that override the method. 20. Implement a class `Rectangle` with methods to calculate area and perimeter. Override these methods in a subclass. 21. Design a class `Calculator` with methods for addition, subtraction, and multiplication. Overload the methods for different parameter types. 22. Implement a class `BankAccount` with methods for deposit and withdrawal. Overload these methods to accept different currencies.

**Composition and Aggregation:** 23. Create a class `University` with an aggregation relationship to classes `Department` and `Professor`. 24. Design a class `Car` that has a composition relationship with classes `Engine` and `Wheel`. 25. Implement a class `Library` with an aggregation relationship to classes `Book` and `Author`. 26. Create a class `Team` that aggregates instances of class `Player`.

**Interfaces and Abstract Methods:** 27. Define an interface `Drawable` with an abstract method `draw`. Implement this interface in classes like `Circle` and `Rectangle`. 28. Create an interface `Soundable` with an abstract method `make_sound`. Implement it in classes like `Dog`, `Cat`, and `Bird`. 29. Implement an interface `Comparable` with an abstract method `compare`. Use it to compare instances of a custom class. 30. Design an interface `Runnable` with an abstract method `run`. Implement it in classes like `Car` and `Bike`.

**Static and Class Methods:** 31. Implement a class `Math` with static methods for common mathematical operations (factorial, square root, etc.). 32. Create a class `StringUtils` with a static method to reverse a string. 33. Implement a class `TimeUtils` with a static method to convert seconds to hours, minutes, and seconds. 34. Design a class `Counter` with a class method to keep track of the number of instances created.

**Operator Overloading:** 35. Overload the `+` operator for a class `Vector` to perform vector addition. 36. Implement custom comparison methods to compare two instances of a class based on a specific attribute. 37. Overload the `*` operator for a class `Matrix` to perform matrix multiplication. 38. Design a class `Fraction` and overload operators `+`, `-`, `*`, and `/` for arithmetic operations.

**Design Patterns:** 39. Implement the Singleton pattern for a class `Logger` to ensure only one instance is created. 40. Use the Factory Method pattern to create different types of `Product` objects based on user input. 41. Design a class `DatabaseConnection` using the Singleton pattern to ensure a single database connection instance. 42. Implement the Observer pattern for a class `Subject` and multiple classes as its observers.

**Dependency Injection:** 43. Create a class `EmailSender` that takes an instance of `Logger` as a dependency to log emails sent. 44. Implement a class `PaymentProcessor` that accepts a payment gateway as a parameter to process payments. 45. Design a class `ReportGenerator` that takes a `DataSource` instance as a dependency to generate reports. 46. Create a class `FileReader` that takes a file path as a dependency to read and process file data.

**Composition Over Inheritance:** 47. Design a class structure for a drawing application using composition to create complex shapes. 48. Create a class `Animal` and a class `Sound` that can be composed to represent the sound an animal makes. 49. Implement a class `Car` that is composed of instances of classes `Engine` and `Wheel`.

**Duck Typing and Polymorphism:** 50. Implement a function that accepts any object with a `speak` method and calls it to produce a sound. 51. Create a generic class `Container` that accepts and manages objects of any type. 52. Design a class `Device` with methods for `turn_on` and `turn_off`. Use it with different classes like `TV` and `Light`.

**Method Chaining:** 53. Implement a class `StringBuilder` with methods to append, reverse, and get the final string. Enable method chaining. 54. Design a class `Query` with methods to add conditions, select columns, and execute the query. Enable method chaining. 55. Create a class `Workflow` with methods for adding steps and executing the workflow. Enable method chaining.

**Data Hiding and Encapsulation:** 56. Create a class `Person` with private attributes for name and age, and methods to access and update them. 57. Implement a class `BankAccount` with a private attribute for balance and methods to deposit and withdraw money. 58. Design a class `Employee` with private attributes for salary and tax rate, and methods

to calculate net pay. 59. Implement a class `Rectangle` with private attributes for length and width, and methods to calculate area and perimeter.
